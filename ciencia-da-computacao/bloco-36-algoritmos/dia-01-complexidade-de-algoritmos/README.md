## DIA-01

**O que vamos aprender?**

> ‚ÄúQu√£o eficiente √© esse algoritmo?‚Äù

Essa pergunta talvez j√° tenha passado pela sua cabe√ßa ao olhar para os c√≥digos que desenvolveu. E √© natural que seja assim, pois a efici√™ncia de um algoritmo √© um dos principais requisitos n√£o funcionais listados em  [levantamentos de requisitos](https://engsoftmoderna.info/cap3.html), tanto por clientes quanto por membros das equipes de desenvolvimento.

Uma pessoa usu√°ria de um site n√£o quer que sua busca por determinada informa√ß√£o demore muito tempo para trazer um retorno. Por exemplo, n√£o √© frustrante quando algum programa causa lentid√£o √† nossa m√°quina em fun√ß√£o da quantidade de recursos que consome!? üò†

Entretanto, n√£o √© somente em experi√™ncia da pessoa usu√°ria que a efici√™ncia de um algoritmo se mostra importante. H√° diversos projetos e pesquisas cient√≠ficas que dependem, por exemplo, do processamento e armazenamento de bases enormes de dados, e que dependem de investimentos financeiros elevados.

Por esse motivo, √© fundamental que as pessoas desenvolvedoras sejam capazes de aumentar a efici√™ncia de seus algoritmos, reduzindo custos envolvidos e entregando a resolu√ß√£o de problemas.

Bora pro conte√∫do? üöÄ

### Voc√™ ser√° capaz de:

-   Descrever a capacidade de analisar o desempenho de um algoritmo como importante para processos seletivos de Big Techs, como Google, Amazon, Facebook, etc.
    
-   Definir o que √©  `algoritmo`;
    
-   Definir o que √© um  `algoritmo correto`;
    
-   Compreender a import√¢ncia da  `an√°lise de algoritmos`;
    
-   Definir  `Ordem de Complexidade`, ou  `Complexidade Assint√≥tica`;
    
-   Compreender as nota√ß√µes que representam a complexidade de um algoritmo, a saber:  `O(1)`,  `O(n)`,  `O(log n)`,  `O(n^2)`,  `O(n^3)`  e  `O(n!)`;
    
-   Definir  `Complexidade de Tempo`  e  `Complexidade de Espa√ßo`;
    
-   Definir a categoria de problemas  `NP-Completo`;
    
-   Combinar fun√ß√µes matem√°ticas para analisar complexidade de algoritmos;
    
-   Definir o  `melhor`, o  `pior`  e o  `caso m√©dio`  de uma  `Ordem de Complexidade`.

